/**
 *
 *
 */
package syntest;

import org.apache.commons.cli.*;

import org.objectweb.asm.*;
import org.objectweb.asm.util.*;
import org.objectweb.asm.commons.*;

import java.lang.Math;
import java.io.PrintWriter;
import java.util.List;
import java.util.stream.Collectors;

import java.lang.management.ManagementFactory;
import java.lang.management.MemoryPoolMXBean;
import java.lang.management.MemoryUsage;
import java.lang.management.MemoryType;

import javax.management.ObjectName;
import javax.management.MBeanServer;


public class SynTest implements Opcodes {

  private final static String packageName = "syntest";
  private final static String classNamePrefix = "SynImpl";

  private static boolean verboseOutput = false;

  private static int numClasses = 20_000;
  private static int warmUps = 10_000;
  private static int numBatches = 1_000;
  private static long itersPerBatch = 1_000;
  private static String compilerDirectivesFile = null;

  private static long batchTime[];
  private static SynTestRunner dtrs[];
  private static long runResult = 0;

  private static List<MemoryPoolMXBean> memoryBeans;

  static class SynClassLoader extends ClassLoader {
    public Class<?> defineClass(String name, byte[] b) {
        return defineClass(name, b, 0, b.length);
    }
  }

  public static byte[] doGenerateClass(String className, SynTestRunner callee) {
    String interfaces[] = { packageName + "/SynTestRunner" };

    ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
    classWriter.visit(V11, ACC_PUBLIC, packageName + "/" + className, null, "java/lang/Object", interfaces);

    MethodVisitor methodVisitor;
    // Code below generated by
    // $(JAVA) -cp $(CLASSPATH) org.objectweb.asm.util.ASMifier syntest/SynTestTemplate.class

    // ctor
    {
      methodVisitor = classWriter.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
      methodVisitor.visitCode();
      Label label0 = new Label();
      methodVisitor.visitLabel(label0);
      methodVisitor.visitLineNumber(3, label0);
      methodVisitor.visitVarInsn(ALOAD, 0);
      methodVisitor.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);
      methodVisitor.visitInsn(RETURN);
      methodVisitor.visitMaxs(1, 1);
      methodVisitor.visitEnd();
    }

   // add
    {
      methodVisitor = classWriter.visitMethod(ACC_PUBLIC, "add", "(II)I", null, null);
      methodVisitor.visitCode();
      Label label0 = new Label();
      methodVisitor.visitLabel(label0);
      methodVisitor.visitLineNumber(5, label0);
      methodVisitor.visitVarInsn(ILOAD, 1);
      methodVisitor.visitVarInsn(ILOAD, 2);
      methodVisitor.visitInsn(IADD);
      methodVisitor.visitInsn(IRETURN);
      methodVisitor.visitMaxs(2, 3);
      methodVisitor.visitEnd();
    }

    // doit
    {
      methodVisitor = classWriter.visitMethod(ACC_PUBLIC, "doit", "(IIILsyntest/SynTestRunner;)I", null, null);
      methodVisitor.visitCode();
      Label label0 = new Label();
      methodVisitor.visitLabel(label0);
      methodVisitor.visitLineNumber(9, label0);
      methodVisitor.visitVarInsn(ILOAD, 1);
      methodVisitor.visitVarInsn(ILOAD, 2);
      methodVisitor.visitInsn(IADD);
      methodVisitor.visitVarInsn(ISTORE, 5);
      Label label1 = new Label();
      methodVisitor.visitLabel(label1);
      methodVisitor.visitLineNumber(10, label1);
      methodVisitor.visitVarInsn(ILOAD, 1);
      methodVisitor.visitVarInsn(ILOAD, 2);
      Label label2 = new Label();
      methodVisitor.visitJumpInsn(IF_ICMPLE, label2);
      Label label3 = new Label();
      methodVisitor.visitLabel(label3);
      methodVisitor.visitLineNumber(11, label3);
      methodVisitor.visitVarInsn(ILOAD, 5);
      methodVisitor.visitVarInsn(ILOAD, 5);
      methodVisitor.visitInsn(IMUL);
      methodVisitor.visitVarInsn(ISTORE, 5);
      Label label4 = new Label();
      methodVisitor.visitLabel(label4);
      methodVisitor.visitLineNumber(12, label4);
      methodVisitor.visitVarInsn(ILOAD, 1);
      methodVisitor.visitVarInsn(ILOAD, 3);
      methodVisitor.visitJumpInsn(IF_ICMPLE, label2);
      Label label5 = new Label();
      methodVisitor.visitLabel(label5);
      methodVisitor.visitLineNumber(13, label5);
      methodVisitor.visitVarInsn(ILOAD, 5);
      methodVisitor.visitVarInsn(ILOAD, 5);
      methodVisitor.visitInsn(IMUL);
      methodVisitor.visitVarInsn(ISTORE, 5);
      methodVisitor.visitLabel(label2);
      methodVisitor.visitLineNumber(17, label2);
      methodVisitor.visitFrame(Opcodes.F_APPEND,1, new Object[] {Opcodes.INTEGER}, 0, null);
      methodVisitor.visitVarInsn(ILOAD, 1);
      methodVisitor.visitVarInsn(ILOAD, 2);
      Label label6 = new Label();
      methodVisitor.visitJumpInsn(IF_ICMPGE, label6);
      Label label7 = new Label();
      methodVisitor.visitLabel(label7);
      methodVisitor.visitLineNumber(18, label7);
      methodVisitor.visitVarInsn(ILOAD, 5);
      methodVisitor.visitVarInsn(ILOAD, 5);
      methodVisitor.visitInsn(IADD);
      methodVisitor.visitVarInsn(ISTORE, 5);
      Label label8 = new Label();
      methodVisitor.visitLabel(label8);
      methodVisitor.visitLineNumber(19, label8);
      methodVisitor.visitVarInsn(ILOAD, 1);
      methodVisitor.visitVarInsn(ILOAD, 3);
      methodVisitor.visitJumpInsn(IF_ICMPGE, label6);
      Label label9 = new Label();
      methodVisitor.visitLabel(label9);
      methodVisitor.visitLineNumber(20, label9);
      methodVisitor.visitVarInsn(ILOAD, 5);
      methodVisitor.visitVarInsn(ILOAD, 5);
      methodVisitor.visitInsn(IADD);
      methodVisitor.visitVarInsn(ISTORE, 5);
      methodVisitor.visitLabel(label6);
      methodVisitor.visitLineNumber(23, label6);
      methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);
      methodVisitor.visitVarInsn(ALOAD, 4);
      Label label10 = new Label();
      methodVisitor.visitJumpInsn(IFNULL, label10);
      Label label11 = new Label();
      methodVisitor.visitLabel(label11);
      methodVisitor.visitLineNumber(24, label11);
      methodVisitor.visitVarInsn(ALOAD, 4);
      methodVisitor.visitIntInsn(BIPUSH, 99);
      methodVisitor.visitIntInsn(BIPUSH, 99);
      methodVisitor.visitIntInsn(BIPUSH, 99);
      methodVisitor.visitInsn(ACONST_NULL);
      methodVisitor.visitMethodInsn(INVOKEINTERFACE, "syntest/SynTestRunner", "doit", "(IIILsyntest/SynTestRunner;)I", true);
      methodVisitor.visitInsn(POP);
      methodVisitor.visitLabel(label10);
      methodVisitor.visitLineNumber(26, label10);
      methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);
      methodVisitor.visitVarInsn(ILOAD, 5);
      methodVisitor.visitInsn(IRETURN);
      methodVisitor.visitMaxs(5, 6);
      methodVisitor.visitEnd();
    }

    classWriter.visitEnd();
    return classWriter.toByteArray();
  }

  public static void printMemoryUsage() {
    System.out.println("---------- Memory Usage ----------");
    for (MemoryPoolMXBean m: memoryBeans) {
      MemoryUsage u = m.getUsage();
      double used = u.getUsed();
      // Skip Java Heap
      if (m.getType() == MemoryType.NON_HEAP) {
        System.out.printf("%s %dKb\n", m.getName(), Math.round(used/1024));
      }
    }
    System.out.println("");
  }

  public static void printCompiledMethods() {
    System.out.println("---------- Compiled Methods ----------");
    String result = do_run_dcmd("compilerCodelist", new String[]{});

    if (verboseOutput) {
      result.lines().forEach(System.out::println);
    }

    List<String> filtered = result.lines().filter(
      (line) -> line.contains(packageName + ".SynImpl_")
    ).collect(Collectors.toList());

    long all_count = filtered.size();
    if (all_count > 0) {
      long counts[] = new long[5];
      long state_counts[] = new long[5];
      long in_use_counts[] = new long[5];
      for (String line : filtered) {
        String fields[] = line.split(" ");
        int state = Integer.valueOf(fields[2]); // account nmethod state see: compiledMethod.hpp
        int comp_level = Integer.valueOf(fields[1]);

        counts[comp_level] += 1;
        if (state != -1) { // skip initializing
          state_counts[state] += 1;
          if (state == 0 /*in_use*/) {
            in_use_counts[comp_level] += 1;
          }
        }
      }

      System.out.println("---------- Compiled Methods Summary --------");
      System.out.printf("Compiled at levels 1: %d 2: %d 3: %d 4: %d\n",
              counts[1], counts[2], counts[3], counts[4]);
      System.out.printf("In use at levels 1: %d 2: %d 3: %d 4: %d\n",
              in_use_counts[1], in_use_counts[2], in_use_counts[3], in_use_counts[4]);
      System.out.printf("CodeCache states in_use: %d not_used: %d not_reentrant: %d zombie: %d unloaded: %d\n",
              state_counts[0], state_counts[1], state_counts[2], state_counts[3], state_counts[4]);

      System.out.printf("Syntetic methods in Codecache (all states): %d\n", all_count);
    }
    else {
      System.out.println("No syntetic methods in Codecache (all states)");
    }

    System.out.println("");
  }

  public static void reloadCompilerDirectives(String filename) {
    System.out.println("---------- Reloading Compiler Directives ----------");
    String result = do_run_dcmd("compilerDirectivesClear", new String[]{""});
    System.out.println("Clear: " + result);
    result = do_run_dcmd("compilerDirectivesAdd", new String[]{ filename });
    System.out.println("Add: " + result);
  }

  private static String do_run_dcmd(String operationName, String operationArgs[]) {
    String result = null;
    try {
      ObjectName objectName = new ObjectName("com.sun.management:type=DiagnosticCommand");
      MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
      Object[] params = new Object[] { operationArgs };
      String[] signature = new String[]{String[].class.getName()};

      result = (String) mbeanServer.invoke(objectName, operationName, params, signature);
    } catch(Throwable ex) {
      ex.printStackTrace();
      System.exit(1);
    }
    return result;
  }

  public static void printStat(int numItems) {
    do_print_stat(numItems, false);
  }

  public static void printFinalStat(int numItems) {
    do_print_stat(numItems, true);
  }

  private static long do_measure(long times) {
    long start = System.currentTimeMillis();
    for (long j = 0; j < times; ++j) {
      for (int i = 0; i < numClasses; ++i) {
        runResult += dtrs[i].doit(i, (int) j, 2, dtrs[(numClasses-1) - i]);
      }
    }
    long end = System.currentTimeMillis();
    return end - start;
  }

  private static void do_print_stat(int numItems, boolean last_call) {
    long total = 0;
    for (int i = 0; i < numItems; ++i) {
      total += batchTime[i];
    }

    double mean = total / numItems;

    double variance = 0;
    for (int i = 0; i < numItems; i++) {
      variance += Math.pow(batchTime[i] - mean, 2);
    }
    variance = variance / numItems;

    double std = Math.sqrt(variance);

    System.out.printf("Executed %d classes, %d times in %d batches\n", numClasses, (long)(numItems * itersPerBatch), numItems);
    if (last_call) {
      System.out.print("Final ");
    }
    System.out.printf("Results %d (%f +- %f)\n", total, mean, std);
  }

  private static void do_execute_test() {
    printMemoryUsage();
    printCompiledMethods();

    System.out.println("Warming Up");
    for (int j = 0; j < warmUps; ++j) {
      for (int i = 0; i < numClasses; ++i) {
        runResult += dtrs[i].doit(i, j, 100, dtrs[0]);
      }
    }
    System.out.println("Warmup result:" + runResult);

    printMemoryUsage();
    printCompiledMethods();

    System.out.println("Executing");
    for (int i = 0; i < numBatches; ++i) {
      batchTime[i] = do_measure(itersPerBatch);
      printStat(i+1);
    }

    System.out.println("Execution result:" + runResult);

    printMemoryUsage();
    printCompiledMethods();
  }

  public static void main(String args[]) {
    System.out.println("Syntetic test starting ...");

    Options options = new Options();
    CommandLineParser parser = new DefaultParser();
    options.addOption("b", "batches", true, "Number of batches to run (default 1_000)");
    options.addOption("c", "classes", true, "Number of classes to run (default 20_000)");
    options.addOption("i", "iterations", true, "Number of iterations within a batch (default 1_000)");
    options.addOption("d", "directives", true, "Additional compiler directives file");
    options.addOption("w", "warmups", true, "Number of warm-up iterations (default 10_000)");
    options.addOption("v", "verbose", false, "Verbose output");
    options.addOption("help", false, "Print this message");

    try {
      CommandLine cmd = parser.parse(options, args);

      if(cmd.hasOption("help")) {
        HelpFormatter formatter = new HelpFormatter();
        formatter.printHelp("syntest", options);
        System.exit(7);
      }

      if(cmd.hasOption("verbose")) {
        verboseOutput = true;
      }

      if(cmd.hasOption("classes")) {
        numClasses = Integer.valueOf(cmd.getOptionValue("classes"));
      }
      if(cmd.hasOption("batches")) {
        numBatches = Integer.valueOf(cmd.getOptionValue("batches"));
      }
      if(cmd.hasOption("iterations")) {
        itersPerBatch = Integer.valueOf(cmd.getOptionValue("iterations"));
      }
      if(cmd.hasOption("warmups")) {
        warmUps = Integer.valueOf(cmd.getOptionValue("warmups"));
      }
      if(cmd.hasOption("directives")) {
        compilerDirectivesFile = cmd.getOptionValue("directives");
      }

      dtrs = new SynTestRunner[numClasses];
      batchTime = new long[numBatches];

      System.out.printf("With flags: %d classes, %d warm-up runs, %d batches, %d iterations per batch\n",
                          numClasses, warmUps, numBatches, itersPerBatch);
    } catch(Throwable ex) {
      System.err.println("Command line error");
      ex.printStackTrace();
      System.exit(7);
    }

    try {
      memoryBeans = ManagementFactory.getMemoryPoolMXBeans();

      System.out.println("Generating");
      for (int i = 0; i < numClasses; ++i) {
        String className = String.format("%s_%04d", classNamePrefix, i);
        byte[] class_ba = doGenerateClass(className, dtrs[0]);
        SynClassLoader loader = new SynClassLoader();
        Class<?> clazz = loader.defineClass(packageName + "." + className, class_ba);
        dtrs[i] = (SynTestRunner) clazz.getDeclaredConstructor().newInstance();
      }

      System.out.println("Smoke check: " + dtrs[0].add(2,2) + " " + dtrs[0].doit(2,2,2, dtrs[0]));

      do_execute_test();

      if (compilerDirectivesFile != null) {
        System.out.println("Reloading compiler directives from: " + compilerDirectivesFile);
        reloadCompilerDirectives(compilerDirectivesFile);
        do_execute_test();
      }

      printFinalStat(numBatches);

    } catch(Throwable ex) {
       System.err.println("Test error");
       ex.printStackTrace();
    }
  }
}
